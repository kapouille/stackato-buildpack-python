#!/usr/bin/env python
import sys
from os import environ, mkdir
from os.path import exists, join
from subprocess import check_output, CalledProcessError, check_call
import re
from utils import *


def get_python(build_dir):
    python_version = environ.get('PYTHON_VERSION', '2.7')

    runtime_file_path = join(build_dir, 'runtime.txt')
    if exists(runtime_file_path):
        python_version_full = open(runtime_file_path).read().strip()

        match = re.search(r'python-([0-9]\.[0-9])(\.[0-9])*',
                          python_version_full)
        if match:
            python_version = match.group(1)
        else:
            print_warning("Runtime version {} "
                          "not supported".format(python_version_full))

        if python_version_full != python_version:
            command = [
                "/opt/ActivePython-{version}"
                "/bin/python{version}".format(version=python_version),
                "-c",
                'import sys; '
                'print('
                '"{0.major}.{0.minor}.{0.micro}"'
                '.format(sys.version_info))'
            ]
            try:
                actual_version = check_output(command, shell=True).strip()
            except CalledProcessError as error:
                print_warning(
                    "Could not check installed python "
                    "version " + python_version_full,
                    str(error))
                sys.exit(2)

            if actual_version != python_version_full:
                print_warning(
                    "Requested Python version {} "
                    "did not match the installed "
                    "version {}".format(python_version_full, actual_version))
                sys.exit(2)

    if not exists("/opt/ActivePython-" + python_version):
        print_warning("ActivePython-python_version is not installed")
        sys.exit(2)

    print_step("Using Python-{} (ActivePython)".format(python_version))

    return "/opt/ActivePython-{}/bin".format(python_version), python_version


def install_requirements(executable, requirements, options):
    version = check_output(
        "{} --version".format(executable),
        shell=True)
    version = version[:version.find('\n')]
    print_step("Installing requirements via " + version)
    if options:
        print_indent("Using options: " + options)
    check_call(
        "{} install {} -r {}".format(
            executable,
            options,
            requirements),
        shell=True)


def install_application(build_dir, python_dir):
    try:
        if exists(join(build_dir, "setup.py")):
            print_step("Installing application package")

            check_call(
                [join(python_dir, "python"),
                 "setup.py"],
                shell=True,
                cwd=build_dir)
        else:
            if exists(join(build_dir, "requirements.pypm")):
                install_requirements(join(python_dir, "pypm"),
                                     "requirements.pypm",
                                     environ.get('PYPM_OPTS', ''))

            if exists(join(build_dir, "requirements.txt")):
                install_requirements(join(python_dir, "pip"),
                                     "requirements.txt",
                                     environ.get('PIP_OPTS', ''))
    except CalledProcessError as error:
        print_warning("The installation failed:",
                      str(error))
        if error.output:
            print_indent(*error.output.split("\n"))
        sys.exit(2)


def build_runtime_environment(build_dir, python_dir, python_version):
    print_step("Building runtime environment")
    profile_d_dirname = join(build_dir, ".profile.d")
    mkdir(profile_d_dirname)
    with open(join(profile_d_dirname, "python.sh")) as f:
        python_user_base = "/app/.python"
        f.write("export PYTHON_VERSION={}\n".format(python_version))
        f.write('PATH="{}/bin:{}:$PATH"\n'.format(python_user_base,
                                                     python_dir))
        f.write("export PYTHONUSERBASE={}\n".format(python_user_base))
        f.write("export PYTHONUNBUFFERED=True\n")


def main():
    build_dir = sys.argv[1]
    #TODO: cache_dir = sys.argv[2]

    python_dir, python_version = get_python(build_dir)

    install_application(build_dir, python_dir)

    build_runtime_environment(build_dir, python_dir, python_version)


if __name__ == "__main__":
    main()
